'use client'

import React, { useMemo, useRef, useEffect, useState } from 'react'
// ScrollBlock type will be generated by Payload after config is registered
// Using inline type for now until types are regenerated
type ScrollBlockType = {
  variant: 'zoom' | 'text-image-scroll' | 'tabs-scroll' | 'title-scale-scroll' | 'bubble-list-scroll'
  background?: any
  richText?: any
  links?: any[]
  zoomSettings?: any
  textImageSettings?: any
  tabsSettings?: any
  titleScaleSettings?: any
  bubbleListSettings?: any
  settings?: any
  blockName?: string | null
  blockType: 'scroll'
}
import { ScrollRenderer } from '@/scroll/variants/registry'
import { convertScrollBlockToConfig, convertBackground } from './utils'
import RichText from '@/components/RichText'
import { CMSLink } from '@/components/Link'
import { getMediaUrl } from '@/utilities/getMediaUrl'
import { Media } from '@/components/Media'
import type { Media as MediaType } from '@/payload-types'
// @ts-expect-error - GSAP doesn't have type definitions
import gsap from 'gsap'
// @ts-expect-error - GSAP doesn't have type definitions
import { ScrollTrigger } from 'gsap/ScrollTrigger'

// Register GSAP plugins
if (typeof window !== 'undefined') {
  gsap.registerPlugin(ScrollTrigger)
}

type Props = ScrollBlockType & {
  disableInnerContainer?: boolean
}

export const ScrollBlock: React.FC<Props> = (props) => {
  const {
    variant,
    background,
    richText,
    links,
    blockName,
    ...restProps
  } = props

  // Convert block data to scroll config
  const scrollConfig = useMemo(() => {
    return convertScrollBlockToConfig(props)
  }, [props])

  // Convert background
  const backgroundData = useMemo(() => {
    return convertBackground(background)
  }, [background])

  // Get media URLs from Payload media objects
  const backgroundImageUrl = useMemo(() => {
    if (backgroundData.type === 'IMAGE' && background?.image) {
      const imageMedia = typeof background.image === 'number' ? null : background.image
      if (imageMedia && imageMedia.url) {
        return getMediaUrl(imageMedia.url)
      }
      // If just an ID, construct URL
      if (typeof background.image === 'number') {
        return getMediaUrl(`/media/${background.image}`)
      }
    }
    return backgroundData.value as string | undefined
  }, [background, backgroundData])

  const backgroundVideoUrl = useMemo(() => {
    if (backgroundData.type === 'VIDEO' && background?.video) {
      const videoMedia = typeof background.video === 'number' ? null : background.video
      if (videoMedia && videoMedia.url) {
        return getMediaUrl(videoMedia.url)
      }
      if (typeof background.video === 'number') {
        return getMediaUrl(`/media/${background.video}`)
      }
    }
    return backgroundData.value as string | undefined
  }, [background, backgroundData])

  // Video loading state
  const [isVideoLoading, setIsVideoLoading] = useState(true)

  useEffect(() => {
    if (backgroundData.type === 'VIDEO') {
      setIsVideoLoading(true)
    }
  }, [backgroundData.type, backgroundVideoUrl])

  // Compute background styles
  const scrollBackgroundStyles = useMemo<React.CSSProperties>(() => {
    if (!background || backgroundData.type === 'NONE') return {}

    const styles: React.CSSProperties = {
      position: 'absolute',
      inset: 0,
      width: '100%',
      height: '100%',
      zIndex: 0,
      overflow: 'hidden',
      contain: 'layout style paint',
      willChange: 'transform',
    }

    switch (backgroundData.type) {
      case 'COLOR':
        styles.backgroundColor = backgroundData.value as string
        break
      case 'GRADIENT':
        styles.background = backgroundData.value as string
        break
      case 'IMAGE': {
        const imageUrl = backgroundImageUrl || (backgroundData.value as string)
        if (imageUrl) {
          styles.backgroundImage = `url(${imageUrl})`
          styles.backgroundSize = backgroundData.size || 'cover'
          styles.backgroundPosition = backgroundData.position || 'center'
          styles.backgroundRepeat = 'no-repeat'
          styles.objectFit = 'cover'
          styles.maxWidth = '100%'
          styles.maxHeight = '100%'
        }
        break
      }
      case 'VIDEO':
      case 'CAROUSEL':
        // These are rendered as elements, not CSS backgrounds
        break
      default:
        break
    }

    if (backgroundData.opacity !== undefined) {
      styles.opacity = backgroundData.opacity
    }

    return styles
  }, [background, backgroundData, backgroundImageUrl])

  // Render background element
  const backgroundElement = useMemo(() => {
    if (!background || backgroundData.type === 'NONE') return null

    // IMAGE, COLOR, GRADIENT - render as div with CSS styles
    if (
      backgroundData.type === 'IMAGE' ||
      backgroundData.type === 'COLOR' ||
      backgroundData.type === 'GRADIENT'
    ) {
      const restStyles = { ...scrollBackgroundStyles }
      delete restStyles.position
      delete restStyles.inset
      delete restStyles.top
      delete restStyles.left
      delete restStyles.right
      delete restStyles.bottom

      return (
        <div
          className="scroll-background"
          style={{
            ...restStyles,
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            width: '100%',
            height: '100%',
            margin: 0,
            padding: 0,
            borderRadius: '0px',
            overflow: 'hidden',
          }}
        />
      )
    }

    // VIDEO - render as video element or Media component
    if (backgroundData.type === 'VIDEO') {
      const videoUrl = backgroundVideoUrl || (backgroundData.value as string)
      if (!videoUrl && !background?.video) return null

      // If we have a media object, use Media component
      if (background?.video && typeof background.video === 'object') {
        return (
          <div
            className="scroll-background absolute inset-0 w-full h-full"
            style={{
              opacity: backgroundData.opacity ?? 1,
              borderRadius: '0px',
              overflow: 'hidden',
            }}
          >
            <Media
              resource={background.video as MediaType}
              className="absolute inset-0 w-full h-full object-cover"
            />
          </div>
        )
      }

      // Fallback to video element
      if (videoUrl) {
        return (
          <video
            className="scroll-background w-full h-full object-cover"
            src={videoUrl}
            autoPlay
            muted
            loop
            playsInline
            preload="auto"
            onLoadStart={() => setIsVideoLoading(true)}
            onCanPlay={() => setIsVideoLoading(false)}
            onWaiting={() => setIsVideoLoading(true)}
            onError={() => setIsVideoLoading(false)}
            style={{
              opacity: backgroundData.opacity ?? 1,
              width: '100%',
              height: '100%',
              borderRadius: '0px',
              overflow: 'hidden',
              position: 'absolute',
              inset: 0,
            }}
          />
        )
      }
      return null
    }

    // CAROUSEL - render image carousel
    if (backgroundData.type === 'CAROUSEL' && background?.carousel?.images) {
      const images = background.carousel.images
      if (images.length > 0) {
        return (
          <div
            className="scroll-background absolute inset-0 w-full h-full"
            style={{
              zIndex: 0,
              overflow: 'hidden',
              borderRadius: '0px',
              opacity: backgroundData.opacity ?? 1,
            }}
          >
            {/* Simple carousel - can be enhanced later */}
            {images.map((item: { image: number | MediaType }, index: number) => {
              const imageMedia = typeof item.image === 'number' ? null : (item.image as MediaType)
              if (!imageMedia) return null
              return (
                <Media
                  key={index}
                  resource={imageMedia}
                  className="absolute inset-0 w-full h-full object-cover"
                />
              )
            })}
          </div>
        )
      }
      return null
    }

    return null
  }, [background, backgroundData, scrollBackgroundStyles, backgroundImageUrl, backgroundVideoUrl, isVideoLoading])

  // For zoom variant, handle section scaling
  const sectionRef = useRef<HTMLElement>(null)
  const scrollTriggerRef = useRef<ScrollTrigger | null>(null)
  const isZoomVariant = scrollConfig.variant === 'zoom'

  // Set up zoom effect for zoom variant
  useEffect(() => {
    if (!isZoomVariant || !sectionRef.current) return

    const { zoomStart = 1, zoomEnd = 0.9, duration = 300, enableOnMobile = true, reducedMotion = false } =
      scrollConfig

    // Check for reduced motion
    if (reducedMotion || (typeof window !== 'undefined' && window.matchMedia('(prefers-reduced-motion: reduce)').matches)) {
      return
    }

    // Check for mobile
    const isMobile = typeof window !== 'undefined' && window.innerWidth <= 768
    if (isMobile && !enableOnMobile) {
      return
    }

    const sectionElement = sectionRef.current
    const backgroundElement = sectionElement.querySelector('.scroll-background') as HTMLElement

    // Set initial scale
    gsap.set(sectionElement, {
      scale: zoomStart,
      transformOrigin: 'center center',
    })

    // Set initial border radius
    if (backgroundElement) {
      gsap.set(backgroundElement, {
        borderRadius: '0px',
      })
    }

    // Create scroll-triggered zoom effect
    const getStartPosition = () => {
      const promotionHeight =
        parseFloat(
          typeof window !== 'undefined'
            ? getComputedStyle(document.documentElement).getPropertyValue('--promotion-height')
            : '0'
        ) || 0

      if (promotionHeight > 0) {
        return `top top-=${promotionHeight}`
      }
      return 'top top'
    }

    scrollTriggerRef.current = ScrollTrigger.create({
      trigger: sectionElement,
      start: getStartPosition(),
      end: `+=${duration}`,
      scrub: true,
      onUpdate: (self: ScrollTrigger) => {
        const progress = self.progress
        const scale = zoomStart + (zoomEnd - zoomStart) * progress
        const borderRadius = 0 + 24 * progress // 0 to 24px

        gsap.set(sectionElement, { scale })

        if (backgroundElement) {
          gsap.set(backgroundElement, {
            borderRadius: `${borderRadius}px`,
          })
        }
      },
      invalidateOnRefresh: true,
    })

    return () => {
      if (scrollTriggerRef.current) {
        scrollTriggerRef.current.kill()
        scrollTriggerRef.current = null
      }
    }
  }, [scrollConfig, isZoomVariant])

  // Section style
  const sectionStyle = useMemo(() => {
    const isZoomVariant = scrollConfig.variant === 'zoom'
    const isTextImageScroll = scrollConfig.variant === 'text-image-scroll'
    const isTabsScroll = scrollConfig.variant === 'tabs-scroll'
    const isBubbleListScroll = scrollConfig.variant === 'bubble-list-scroll'

    const baseStyle: React.CSSProperties = {
      position: 'relative',
      width: '100%',
      ...(isZoomVariant ? { minHeight: '100vh', height: '100vh' } : {}),
      ...(!isZoomVariant && !isTextImageScroll && !isTabsScroll && !isBubbleListScroll
        ? { minHeight: 'auto', height: 'auto' }
        : {}),
      overflow: isTextImageScroll || isTabsScroll || isBubbleListScroll ? 'visible' : 'hidden',
      ...(isTextImageScroll || isTabsScroll || isBubbleListScroll ? {} : { isolation: 'isolate' }),
      zIndex: 1,
      ...(isZoomVariant && {
        transformOrigin: 'center center',
        willChange: 'transform',
      }),
    }

    return baseStyle
  }, [scrollConfig.variant])

  // Render content (richText + links)
  const content = useMemo(() => {
    return (
      <div className="relative z-10 w-full">
        {richText && (
          <div className="text-center">
            <RichText data={richText} enableGutter={false} />
          </div>
        )}
        {links && Array.isArray(links) && links.length > 0 && (
          <div className="flex justify-center gap-4 mt-6">
            {links.map((linkItem, index) => (
              <CMSLink key={index} {...linkItem.link} />
            ))}
          </div>
        )}
      </div>
    )
  }, [richText, links])

  // For zoom variant, wrap in container that allows scaling
  if (isZoomVariant) {
    return (
      <div
        className="scroll-zoom-wrapper"
        style={{
          position: 'relative',
          width: '100%',
          minHeight: '100vh',
          padding: '0',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          overflow: 'visible',
          maxWidth: 'none',
          boxSizing: 'border-box',
          borderRadius: '0px',
          zIndex: 1,
        }}
      >
        <section
          ref={sectionRef}
          className="scroll-section-enhanced"
          data-scroll-variant={scrollConfig.variant}
          style={{
            ...sectionStyle,
            borderRadius: '0px',
            overflow: 'visible',
          }}
        >
          <ScrollRenderer
            config={scrollConfig}
            backgroundElement={backgroundElement}
            className="w-full h-full"
            style={{
              minHeight: '100vh',
              height: 'auto',
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              justifyContent: 'center',
              position: 'relative',
              overflow: 'visible',
              width: '100%',
              borderRadius: '0px',
            }}
            isEditing={false}
            debugMode={false}
          >
            {content}
          </ScrollRenderer>
        </section>
      </div>
    )
  }

  // For non-zoom variants, render normally
  const isTextImageScroll = scrollConfig.variant === 'text-image-scroll'
  const isTabsScroll = scrollConfig.variant === 'tabs-scroll'
  const isBubbleListScroll = scrollConfig.variant === 'bubble-list-scroll'

  return (
    <section
      className="scroll-section-enhanced"
      data-scroll-variant={scrollConfig.variant}
      style={sectionStyle}
    >
      <ScrollRenderer
        config={scrollConfig}
        backgroundElement={backgroundElement}
        className={isTextImageScroll || isTabsScroll || isBubbleListScroll ? 'w-full' : 'w-full h-full'}
        style={
          isTextImageScroll || isTabsScroll || isBubbleListScroll
            ? {
                position: 'relative',
                overflow: 'visible',
                width: '100%',
              }
            : {
                minHeight: '100vh',
                height: 'auto',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                position: 'relative',
                overflow: 'visible',
                width: '100%',
              }
        }
        isEditing={false}
        debugMode={false}
      >
        {content}
      </ScrollRenderer>
    </section>
  )
}
